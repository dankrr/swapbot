(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.BbobParser = {})));
}(this, (function (exports) { 'use strict';

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	var char_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	var N = '\n';
	var TAB = '\t';
	var F = '\f';
	var R = '\r';

	var EQ = '=';
	var QUOTEMARK = '"';
	var SPACE = ' ';

	var OPEN_BRAKET = '[';
	var CLOSE_BRAKET = ']';

	var SLASH = '/';
	var BACKSLASH = '\\';

	var PLACEHOLDER_SPACE_TAB = '    ';
	var PLACEHOLDER_SPACE = ' ';

	// const getChar = String.fromCharCode;

	exports.N = N;
	exports.F = F;
	exports.R = R;
	exports.TAB = TAB;
	exports.EQ = EQ;
	exports.QUOTEMARK = QUOTEMARK;
	exports.SPACE = SPACE;
	exports.OPEN_BRAKET = OPEN_BRAKET;
	exports.CLOSE_BRAKET = CLOSE_BRAKET;
	exports.SLASH = SLASH;
	exports.PLACEHOLDER_SPACE_TAB = PLACEHOLDER_SPACE_TAB;
	exports.PLACEHOLDER_SPACE = PLACEHOLDER_SPACE;
	exports.BACKSLASH = BACKSLASH;
	});

	unwrapExports(char_1);
	var char_2 = char_1.N;
	var char_3 = char_1.F;
	var char_4 = char_1.R;
	var char_5 = char_1.TAB;
	var char_6 = char_1.EQ;
	var char_7 = char_1.QUOTEMARK;
	var char_8 = char_1.SPACE;
	var char_9 = char_1.OPEN_BRAKET;
	var char_10 = char_1.CLOSE_BRAKET;
	var char_11 = char_1.SLASH;
	var char_12 = char_1.PLACEHOLDER_SPACE_TAB;
	var char_13 = char_1.PLACEHOLDER_SPACE;
	var char_14 = char_1.BACKSLASH;

	var lib = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.isEOL = exports.isStringNode = exports.isTagNode = exports.getNodeLength = exports.appendToNode = exports.attrValue = undefined;



	var isTagNode = function isTagNode(el) {
	  return typeof el === 'object' && !!el.tag;
	};
	var isStringNode = function isStringNode(el) {
	  return typeof el === 'string';
	};
	var isEOL = function isEOL(el) {
	  return el === char_1.N;
	};

	var getNodeLength = function getNodeLength(node) {
	  if (isTagNode(node)) {
	    return node.content.reduce(function (count, contentNode) {
	      return count + getNodeLength(contentNode);
	    }, 0);
	  } else if (isStringNode(node)) {
	    return node.length;
	  }

	  return 0;
	};

	var appendToNode = function appendToNode(node, value) {
	  node.content.push(value);
	};

	var escapeQuote = function escapeQuote(value) {
	  return value.replace(/"/g, '&quot;');
	};

	var attrValue = function attrValue(name, value) {
	  var type = typeof value;

	  var types = {
	    boolean: function boolean() {
	      return value ? '' + name : '';
	    },
	    number: function number() {
	      return name + '="' + value + '"';
	    },
	    string: function string() {
	      return name + '="' + escapeQuote(value) + '"';
	    },
	    object: function object() {
	      return name + '="' + escapeQuote(JSON.stringify(value)) + '"';
	    }
	  };

	  return types[type] ? types[type]() : '';
	};

	exports.attrValue = attrValue;
	exports.appendToNode = appendToNode;
	exports.getNodeLength = getNodeLength;
	exports.isTagNode = isTagNode;
	exports.isStringNode = isStringNode;
	exports.isEOL = isEOL;
	});

	unwrapExports(lib);
	var lib_1 = lib.isEOL;
	var lib_2 = lib.isStringNode;
	var lib_3 = lib.isTagNode;
	var lib_4 = lib.getNodeLength;
	var lib_5 = lib.appendToNode;
	var lib_6 = lib.attrValue;

	var TagNode_1 = createCommonjsModule(function (module, exports) {

	exports.__esModule = true;
	exports.TagNode = undefined;

	var _createClass = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
	    }
	  }return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
	  };
	}();





	function _classCallCheck(instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	}

	var TagNode = function () {
	  function TagNode(tag, attrs, content) {
	    _classCallCheck(this, TagNode);

	    this.tag = tag;
	    this.attrs = attrs;
	    this.content = [].concat(content);
	  }

	  TagNode.prototype.attr = function attr(name, value) {
	    if (typeof value !== 'undefined') {
	      this.attrs[name] = value;
	    }

	    return this.attrs[name];
	  };

	  TagNode.prototype.append = function append(value) {
	    return (0, lib.appendToNode)(this, value);
	  };

	  TagNode.prototype.toString = function toString() {
	    var OB = char_1.OPEN_BRAKET;
	    var CB = char_1.CLOSE_BRAKET;

	    return OB + this.tag + CB + this.content.reduce(function (r, node) {
	      return r + node.toString();
	    }, '') + OB + char_1.SLASH + this.tag + CB;
	  };

	  _createClass(TagNode, [{
	    key: 'length',
	    get: function get() {
	      return (0, lib.getNodeLength)(this);
	    }
	  }]);

	  return TagNode;
	}();

	TagNode.create = function (tag) {
	  var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var content = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
	  return new TagNode(tag, attrs, content);
	};
	TagNode.isOf = function (node, type) {
	  return node.tag === type;
	};

	exports.TagNode = TagNode;
	exports.default = TagNode;
	});

	var TagNode = unwrapExports(TagNode_1);
	var TagNode_2 = TagNode_1.TagNode;

	var classCallCheck = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

	// type, value, line, row,
	var TOKEN_TYPE_ID = 'type'; // 0;
	var TOKEN_VALUE_ID = 'value'; // 1;
	var TOKEN_COLUMN_ID = 'row'; // 2;
	var TOKEN_LINE_ID = 'line'; // 3;

	var TOKEN_TYPE_WORD = 'word';
	var TOKEN_TYPE_TAG = 'tag';
	var TOKEN_TYPE_ATTR_NAME = 'attr-name';
	var TOKEN_TYPE_ATTR_VALUE = 'attr-value';
	var TOKEN_TYPE_SPACE = 'space';
	var TOKEN_TYPE_NEW_LINE = 'new-line';

	var getTokenValue = function getTokenValue(token) {
	  return token[TOKEN_VALUE_ID];
	};
	var getTokenLine = function getTokenLine(token) {
	  return token[TOKEN_LINE_ID];
	};
	var getTokenColumn = function getTokenColumn(token) {
	  return token[TOKEN_COLUMN_ID];
	};

	var isTextToken = function isTextToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;
	};

	var isTagToken = function isTagToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;
	};
	var isTagEnd = function isTagEnd(token) {
	  return getTokenValue(token).charCodeAt(0) === char_11.charCodeAt(0);
	};
	var isTagStart = function isTagStart(token) {
	  return !isTagEnd(token);
	};
	var isAttrNameToken = function isAttrNameToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;
	};
	var isAttrValueToken = function isAttrValueToken(token) {
	  return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;
	};

	var getTagName = function getTagName(token) {
	  var value = getTokenValue(token);

	  return isTagEnd(token) ? value.slice(1) : value;
	};

	var convertTagToText = function convertTagToText(token) {
	  var text = char_9;

	  if (isTagEnd(token)) {
	    text += char_11;
	  }

	  text += getTokenValue(token);
	  text += char_10;

	  return text;
	};

	var Token = function () {
	  /**
	   * @param {String} type
	   * @param {String} value
	   * @param line
	   * @param row
	   */
	  function Token(type, value, line, row) {
	    classCallCheck(this, Token);

	    this[TOKEN_TYPE_ID] = String(type);
	    this[TOKEN_VALUE_ID] = String(value);
	    this[TOKEN_LINE_ID] = Number(line);
	    this[TOKEN_COLUMN_ID] = Number(row);
	  }

	  Token.prototype.isEmpty = function isEmpty() {
	    return !!this[TOKEN_TYPE_ID];
	  };

	  Token.prototype.isText = function isText() {
	    return isTextToken(this);
	  };

	  Token.prototype.isTag = function isTag() {
	    return isTagToken(this);
	  };

	  Token.prototype.isAttrName = function isAttrName() {
	    return isAttrNameToken(this);
	  };

	  Token.prototype.isAttrValue = function isAttrValue() {
	    return isAttrValueToken(this);
	  };

	  Token.prototype.isStart = function isStart() {
	    return isTagStart(this);
	  };

	  Token.prototype.isEnd = function isEnd() {
	    return isTagEnd(this);
	  };

	  Token.prototype.getName = function getName() {
	    return getTagName(this);
	  };

	  Token.prototype.getValue = function getValue() {
	    return getTokenValue(this);
	  };

	  Token.prototype.getLine = function getLine() {
	    return getTokenLine(this);
	  };

	  Token.prototype.getColumn = function getColumn() {
	    return getTokenColumn(this);
	  };

	  Token.prototype.toString = function toString() {
	    return convertTagToText(this);
	  };

	  return Token;
	}();
	var TYPE_WORD = TOKEN_TYPE_WORD;
	var TYPE_TAG = TOKEN_TYPE_TAG;
	var TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;
	var TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;
	var TYPE_SPACE = TOKEN_TYPE_SPACE;
	var TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;

	/* eslint-disable no-plusplus,no-param-reassign */

	var EM = '!';

	var createCharGrabber = function createCharGrabber(source) {
	  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
	      onSkip = _ref.onSkip;

	  var idx = 0;

	  var skip = function skip() {
	    idx += 1;

	    if (onSkip) {
	      onSkip();
	    }
	  };
	  var hasNext = function hasNext() {
	    return source.length > idx;
	  };
	  var getRest = function getRest() {
	    return source.substr(idx);
	  };

	  return {
	    skip: skip,
	    hasNext: hasNext,
	    isLast: function isLast() {
	      return idx === source.length;
	    },
	    grabWhile: function grabWhile(cond) {
	      var start = idx;

	      while (hasNext() && cond(source[idx])) {
	        skip();
	      }

	      return source.substr(start, idx - start);
	    },
	    getNext: function getNext() {
	      return source[idx + 1];
	    },
	    getPrev: function getPrev() {
	      return source[idx - 1];
	    },
	    getCurr: function getCurr() {
	      return source[idx];
	    },
	    getRest: getRest,
	    substrUntilChar: function substrUntilChar(char$$1) {
	      var restStr = getRest();
	      var indexOfChar = restStr.indexOf(char$$1);

	      if (indexOfChar >= 0) {
	        return restStr.substr(0, indexOfChar);
	      }

	      return '';
	    }
	  };
	};

	var trimChar = function trimChar(str, charToRemove) {
	  while (str.charAt(0) === charToRemove) {
	    str = str.substring(1);
	  }

	  while (str.charAt(str.length - 1) === charToRemove) {
	    str = str.substring(0, str.length - 1);
	  }

	  return str;
	};

	var unquote = function unquote(str) {
	  return str.replace(char_14 + char_7, char_7);
	};
	var createToken = function createToken(type, value) {
	  var r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
	  var cl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
	  return new Token(type, value, r, cl);
	};

	/**
	 * @typedef {Object} Lexer
	 * @property {Function} tokenize
	 * @property {Function} isTokenNested
	 */

	/**
	 * @param {String} buffer
	 * @param {Object} options
	 * @param {Function} options.onToken
	 * @param {String} options.openTag
	 * @param {String} options.closeTag
	 * @return {Lexer}
	 */
	function createLexer(buffer) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  var row = 0;
	  var col = 0;

	  var tokenIndex = -1;
	  var tokens = new Array(Math.floor(buffer.length));
	  var openTag = options.openTag || char_9;
	  var closeTag = options.closeTag || char_10;

	  var RESERVED_CHARS = [closeTag, openTag, char_7, char_14, char_8, char_5, char_6, char_2, EM];
	  var NOT_CHAR_TOKENS = [openTag, char_8, char_5, char_2];
	  var WHITESPACES = [char_8, char_5];
	  var SPECIAL_CHARS = [char_6, char_8, char_5];

	  var isCharReserved = function isCharReserved(char$$1) {
	    return RESERVED_CHARS.indexOf(char$$1) >= 0;
	  };
	  var isWhiteSpace = function isWhiteSpace(char$$1) {
	    return WHITESPACES.indexOf(char$$1) >= 0;
	  };
	  var isCharToken = function isCharToken(char$$1) {
	    return NOT_CHAR_TOKENS.indexOf(char$$1) === -1;
	  };
	  var isSpecialChar = function isSpecialChar(char$$1) {
	    return SPECIAL_CHARS.indexOf(char$$1) >= 0;
	  };

	  var emitToken = function emitToken(token) {
	    if (options.onToken) {
	      options.onToken(token);
	    }

	    tokenIndex += 1;
	    tokens[tokenIndex] = token;
	  };

	  var parseAttrs = function parseAttrs(str) {
	    var tagName = null;
	    var skipSpecialChars = false;

	    var attrTokens = [];
	    var attrCharGrabber = createCharGrabber(str);

	    var validAttr = function validAttr(char$$1) {
	      var isEQ = char$$1 === char_6;
	      var isWS = isWhiteSpace(char$$1);
	      var prevChar = attrCharGrabber.getPrev();
	      var nextChar = attrCharGrabber.getNext();
	      var isPrevSLASH = prevChar === char_14;
	      var isTagNameEmpty = tagName === null;

	      if (isTagNameEmpty) {
	        return (isEQ || isWS || attrCharGrabber.isLast()) === false;
	      }

	      if (skipSpecialChars && isSpecialChar(char$$1)) {
	        return true;
	      }

	      if (char$$1 === char_7 && !isPrevSLASH) {
	        skipSpecialChars = !skipSpecialChars;

	        if (!skipSpecialChars && !(nextChar === char_6 || isWhiteSpace(nextChar))) {
	          return false;
	        }
	      }

	      return (isEQ || isWS) === false;
	    };

	    var nextAttr = function nextAttr() {
	      var attrStr = attrCharGrabber.grabWhile(validAttr);
	      var currChar = attrCharGrabber.getCurr();

	      // first string before space is a tag name
	      if (tagName === null) {
	        tagName = attrStr;
	      } else if (isWhiteSpace(currChar) || currChar === char_7 || !attrCharGrabber.hasNext()) {
	        var escaped = unquote(trimChar(attrStr, char_7));
	        attrTokens.push(createToken(TYPE_ATTR_VALUE, escaped, row, col));
	      } else {
	        attrTokens.push(createToken(TYPE_ATTR_NAME, attrStr, row, col));
	      }

	      attrCharGrabber.skip();
	    };

	    while (attrCharGrabber.hasNext()) {
	      nextAttr();
	    }

	    return { tag: tagName, attrs: attrTokens };
	  };

	  var bufferGrabber = createCharGrabber(buffer, {
	    onSkip: function onSkip() {
	      col++;
	    }
	  });

	  var next = function next() {
	    var char$$1 = bufferGrabber.getCurr();

	    if (char$$1 === char_2) {
	      bufferGrabber.skip();
	      col = 0;
	      row++;

	      emitToken(createToken(TYPE_NEW_LINE, char$$1, row, col));
	    } else if (isWhiteSpace(char$$1)) {
	      var str = bufferGrabber.grabWhile(isWhiteSpace);
	      emitToken(createToken(TYPE_SPACE, str, row, col));
	    } else if (char$$1 === openTag) {
	      var nextChar = bufferGrabber.getNext();
	      bufferGrabber.skip(); // skip openTag

	      // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'
	      var substr = bufferGrabber.substrUntilChar(closeTag);
	      var hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;

	      if (isCharReserved(nextChar) || hasInvalidChars || bufferGrabber.isLast()) {
	        emitToken(createToken(TYPE_WORD, char$$1, row, col));
	      } else {
	        var _str = bufferGrabber.grabWhile(function (val) {
	          return val !== closeTag;
	        });

	        bufferGrabber.skip(); // skip closeTag
	        var isNoAttrsInTag = _str.indexOf(char_6) === -1;
	        var isClosingTag = _str[0] === char_11;

	        if (isNoAttrsInTag || isClosingTag) {
	          emitToken(createToken(TYPE_TAG, _str, row, col));
	        } else {
	          var parsed = parseAttrs(_str);

	          emitToken(createToken(TYPE_TAG, parsed.tag, row, col));
	          parsed.attrs.map(emitToken);
	        }
	      }
	    } else if (char$$1 === closeTag) {
	      bufferGrabber.skip();

	      emitToken(createToken(TYPE_WORD, char$$1, row, col));
	    } else if (isCharToken(char$$1)) {
	      var _str2 = bufferGrabber.grabWhile(isCharToken);

	      emitToken(createToken(TYPE_WORD, _str2, row, col));
	    }
	  };

	  var tokenize = function tokenize() {
	    while (bufferGrabber.hasNext()) {
	      next();
	    }

	    tokens.length = tokenIndex + 1;

	    return tokens;
	  };

	  var isTokenNested = function isTokenNested(token) {
	    var value = openTag + char_11 + token.getValue();
	    return buffer.indexOf(value) > -1;
	  };

	  return {
	    tokenize: tokenize,
	    isTokenNested: isTokenNested
	  };
	}

	/**
	 * @private
	 * @type {Array}
	 */
	var nodes = void 0;
	/**
	 * @private
	 * @type {Array}
	 */
	var nestedNodes = void 0;
	/**
	 * @private
	 * @type {Array}
	 */
	var tagNodes = void 0;
	/**
	 * @private
	 * @type {Array}
	 */
	var tagNodesAttrName = void 0;

	var options = {};
	var tokenizer = null;

	// eslint-disable-next-line no-unused-vars
	var tokens = null;

	/**
	 * @private
	 * @param token
	 * @return {*}
	 */
	var isTagNested = function isTagNested(token) {
	  return tokenizer.isTokenNested(token);
	};

	/**
	 * @private
	 * @return {TagNode}
	 */
	var getLastTagNode = function getLastTagNode() {
	  return tagNodes.length ? tagNodes[tagNodes.length - 1] : null;
	};

	/**
	 * @private
	 * @param {Token} token
	 * @return {Array}
	 */
	var createTagNode = function createTagNode(token) {
	  return tagNodes.push(TagNode.create(token.getValue()));
	};
	/**
	 * @private
	 * @param {Token} token
	 * @return {Array}
	 */
	var createTagNodeAttrName = function createTagNodeAttrName(token) {
	  return tagNodesAttrName.push(token.getValue());
	};

	/**
	 * @private
	 * @return {Array}
	 */
	var getTagNodeAttrName = function getTagNodeAttrName() {
	  return tagNodesAttrName.length ? tagNodesAttrName[tagNodesAttrName.length - 1] : null;
	};

	/**
	 * @private
	 * @return {Array}
	 */
	var clearTagNodeAttrName = function clearTagNodeAttrName() {
	  if (tagNodesAttrName.length) {
	    tagNodesAttrName.pop();
	  }
	};

	/**
	 * @private
	 * @return {Array}
	 */
	var clearTagNode = function clearTagNode() {
	  if (tagNodes.length) {
	    tagNodes.pop();

	    clearTagNodeAttrName();
	  }
	};

	/**
	 * @private
	 * @return {Array}
	 */
	var getNodes = function getNodes() {
	  if (nestedNodes.length) {
	    var nestedNode = nestedNodes[nestedNodes.length - 1];

	    return nestedNode.content;
	  }

	  return nodes;
	};

	/**
	 * @private
	 * @param tag
	 */
	var appendNode = function appendNode(tag) {
	  getNodes().push(tag);
	};

	/**
	 * @private
	 * @param value
	 * @return {boolean}
	 */
	var isAllowedTag = function isAllowedTag(value) {
	  if (options.onlyAllowTags && options.onlyAllowTags.length) {
	    return options.onlyAllowTags.indexOf(value) >= 0;
	  }

	  return true;
	};
	/**
	 * @private
	 * @param {Token} token
	 */
	var handleTagStart = function handleTagStart(token) {
	  if (token.isStart()) {
	    createTagNode(token);

	    if (isTagNested(token)) {
	      nestedNodes.push(getLastTagNode());
	    } else {
	      appendNode(getLastTagNode());
	      clearTagNode();
	    }
	  }
	};

	/**
	 * @private
	 * @param {Token} token
	 */
	var handleTagEnd = function handleTagEnd(token) {
	  if (token.isEnd()) {
	    clearTagNode();

	    var lastNestedNode = nestedNodes.pop();

	    if (lastNestedNode) {
	      appendNode(lastNestedNode);
	    } else if (options.onError) {
	      var tag = token.getValue();
	      var line = token.getLine();
	      var column = token.getColumn();

	      options.onError({
	        message: 'Inconsistent tag \'' + tag + '\' on line ' + line + ' and column ' + column,
	        lineNumber: line,
	        columnNumber: column
	      });
	    }
	  }
	};

	/**
	 * @private
	 * @param {Token} token
	 */
	var handleTagToken = function handleTagToken(token) {
	  if (token.isTag()) {
	    if (isAllowedTag(token.getName())) {
	      // [tag]
	      handleTagStart(token);

	      // [/tag]
	      handleTagEnd(token);
	    } else {
	      appendNode(token.toString());
	    }
	  }
	};

	/**
	 * @private
	 * @param {Token} token
	 */
	var handleTagNode = function handleTagNode(token) {
	  var tagNode = getLastTagNode();

	  if (tagNode) {
	    if (token.isAttrName()) {
	      createTagNodeAttrName(token);
	      tagNode.attr(getTagNodeAttrName(), '');
	    } else if (token.isAttrValue()) {
	      var attrName = getTagNodeAttrName();
	      var attrValue = token.getValue();

	      if (attrName) {
	        tagNode.attr(getTagNodeAttrName(), attrValue);
	        clearTagNodeAttrName();
	      } else {
	        tagNode.attr(attrValue, attrValue);
	      }
	    } else if (token.isText()) {
	      tagNode.append(token.getValue());
	    }
	  } else if (token.isText()) {
	    appendNode(token.getValue());
	  }
	};

	/**
	 * @private
	 * @param token
	 */
	var parseToken = function parseToken(token) {
	  handleTagToken(token);
	  handleTagNode(token);
	};

	/**
	 * @public
	 * @return {Array}
	 */
	var parse = function parse(input) {
	  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

	  options = opts;
	  tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {
	    onToken: parseToken,
	    onlyAllowTags: options.onlyAllowTags,
	    openTag: options.openTag,
	    closeTag: options.closeTag
	  });

	  nodes = [];
	  nestedNodes = [];
	  tagNodes = [];
	  tagNodesAttrName = [];

	  tokens = tokenizer.tokenize();

	  return nodes;
	};

	exports.default = parse;
	exports.parse = parse;
	exports.TagNode = TagNode_2;

	Object.defineProperty(exports, '__esModule', { value: true });

})));
